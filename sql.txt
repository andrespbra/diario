
-- 1. LIMPEZA TOTAL (PARA REMOVER POLÍTICAS QUE CAUSAM RECURSÃO)
DROP POLICY IF EXISTS "safe_read_profiles" ON public.user_profiles;
DROP POLICY IF EXISTS "safe_update_own_profile" ON public.user_profiles;
DROP POLICY IF EXISTS "safe_read_tickets" ON public.tickets;
DROP POLICY IF EXISTS "safe_insert_tickets" ON public.tickets;
DROP POLICY IF EXISTS "safe_update_tickets" ON public.tickets;
DROP POLICY IF EXISTS "safe_delete_tickets" ON public.tickets;
DROP POLICY IF EXISTS "Profiles_Read_All" ON public.user_profiles;
DROP POLICY IF EXISTS "Profiles_Update_Own" ON public.user_profiles;
DROP POLICY IF EXISTS "Tickets_Read_All" ON public.tickets;
DROP POLICY IF EXISTS "Tickets_Insert_Auth" ON public.tickets;

-- 2. FUNÇÃO AUXILIAR PARA EVITAR RECURSÃO
-- Esta função ignora o RLS para checar se o usuário é admin
CREATE OR REPLACE FUNCTION public.check_is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.user_profiles 
    WHERE id = auth.uid() AND nivel = 'Admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. POLÍTICAS PARA USER_PROFILES (À PROVA DE LOOP)
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- QUALQUER UM LOGADO PODE LER PERFIS (Essencial para evitar a recursão)
CREATE POLICY "profiles_select_policy" 
ON public.user_profiles FOR SELECT 
TO authenticated 
USING (true);

-- APENAS O PRÓPRIO OU ADMIN PODE ATUALIZAR
CREATE POLICY "profiles_update_policy" 
ON public.user_profiles FOR UPDATE 
TO authenticated 
USING (auth.uid() = id OR public.check_is_admin());

-- 4. POLÍTICAS PARA TICKETS
ALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;

-- LEITURA: Todos os técnicos veem todos os chamados
CREATE POLICY "tickets_select_policy" 
ON public.tickets FOR SELECT 
TO authenticated 
USING (true);

-- INSERÇÃO: Técnico insere seu próprio chamado
CREATE POLICY "tickets_insert_policy" 
ON public.tickets FOR INSERT 
TO authenticated 
WITH CHECK (auth.uid() = user_id);

-- ATUALIZAÇÃO: Todos podem atualizar (fluxo colaborativo N1 -> N2 -> Tiger)
CREATE POLICY "tickets_update_policy" 
ON public.tickets FOR UPDATE 
TO authenticated 
USING (true);

-- DELEÇÃO: Apenas o dono ou Admin
CREATE POLICY "tickets_delete_policy" 
ON public.tickets FOR DELETE 
TO authenticated 
USING (auth.uid() = user_id OR public.check_is_admin());

-- 5. TRIGGER DE CRIAÇÃO AUTOMÁTICA DE PERFIL (CASO NÃO EXISTA)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.user_profiles (id, name, username, nivel, must_change_password)
  VALUES (
    new.id, 
    COALESCE(new.raw_user_meta_data->>'name', split_part(new.email, '@', 1)), 
    COALESCE(new.raw_user_meta_data->>'username', split_part(new.email, '@', 1)), 
    COALESCE(new.raw_user_meta_data->>'nivel', 'Analista'), 
    true
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
